#!/usr/bin/env node

/**
 * üéØ SCRIPT DE DEMONSTRA√á√ÉO - STELLARGRID TOKEN
 * 
 * Este script demonstra todas as funcionalidades do StellarGrid Token
 * de forma automatizada para apresenta√ß√µes em hackathons.
 * 
 * Funcionalidades demonstradas:
 * - Consulta de metadados do token
 * - Registro de geradores de energia
 * - Mint de tokens de energia
 * - Transfer√™ncias entre contas
 * - Consulta de saldos
 * - Estat√≠sticas gerais
 */

const { Keypair } = require('@stellar/stellar-sdk');
const axios = require('axios');
const chalk = require('chalk');
const ora = require('ora');
const Table = require('cli-table3');

// Configura√ß√µes
const API_BASE_URL = process.env.API_URL || 'http://localhost:3001/api';
const CONTRACT_ID = 'CBEXN3HDQZQL4QDUDUPXKUIDL7IQP57IFIXCW5T5TSLSTMXJNP5SMNRC';

// Criar cliente HTTP
const api = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Utilit√°rios de display
const log = {
  title: (text) => console.log(chalk.bold.cyan(`\nüåü ${text}`)),
  success: (text) => console.log(chalk.green(`‚úÖ ${text}`)),
  info: (text) => console.log(chalk.blue(`‚ÑπÔ∏è  ${text}`)),
  warning: (text) => console.log(chalk.yellow(`‚ö†Ô∏è  ${text}`)),
  error: (text) => console.log(chalk.red(`‚ùå ${text}`)),
  data: (data) => console.log(chalk.gray(JSON.stringify(data, null, 2)))
};

// Fun√ß√£o para aguardar
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Fun√ß√£o para formatar valores
const formatTokens = (stroops) => {
  return `${(stroops / 10000000).toFixed(7)} STRGRID`;
};

class StellarGridDemo {
  constructor() {
    this.accounts = {
      deployer: null,
      generator1: null,
      generator2: null,
      consumer1: null,
      consumer2: null
    };
    this.results = {};
  }

  // Inicializar contas de demonstra√ß√£o
  async initializeAccounts() {
    log.title('INICIALIZANDO CONTAS DE DEMONSTRA√á√ÉO');
    
    // Gerar keypairs para demonstra√ß√£o
    this.accounts.deployer = Keypair.random();
    this.accounts.generator1 = Keypair.random();
    this.accounts.generator2 = Keypair.random();
    this.accounts.consumer1 = Keypair.random();
    this.accounts.consumer2 = Keypair.random();

    const table = new Table({
      head: ['Tipo', 'Endere√ßo P√∫blico', 'Fun√ß√£o'],
      colWidths: [15, 60, 30]
    });

    table.push(
      ['Deployer', this.accounts.deployer.publicKey(), 'Administrador do contrato'],
      ['Generator 1', this.accounts.generator1.publicKey(), 'Painel solar residencial'],
      ['Generator 2', this.accounts.generator2.publicKey(), 'Fazenda e√≥lica'],
      ['Consumer 1', this.accounts.consumer1.publicKey(), 'Resid√™ncia urbana'],
      ['Consumer 2', this.accounts.consumer2.publicKey(), 'Pequena empresa']
    );

    console.log(table.toString());
    log.success('Contas de demonstra√ß√£o criadas com sucesso!');
  }

  // Verificar status da API
  async checkApiStatus() {
    log.title('VERIFICANDO STATUS DA API');
    
    const spinner = ora('Conectando com a API...').start();
    
    try {
      const response = await api.get('/health');
      spinner.succeed('API est√° online e funcionando!');
      
      log.info(`Ambiente: ${response.data.environment}`);
      log.info(`Uptime: ${Math.floor(response.data.uptime)} segundos`);
      
      return true;
    } catch (error) {
      spinner.fail('Falha ao conectar com a API');
      log.error(`Erro: ${error.message}`);
      log.warning('Certifique-se de que a API est√° rodando em http://localhost:3001');
      return false;
    }
  }

  // Obter metadados do token
  async getTokenMetadata() {
    log.title('CONSULTANDO METADADOS DO TOKEN');
    
    const spinner = ora('Obtendo metadados...').start();
    
    try {
      const response = await api.get('/token/metadata');
      const metadata = response.data.data;
      
      spinner.succeed('Metadados obtidos com sucesso!');
      
      const table = new Table();
      table.push(
        ['Nome', metadata.name],
        ['S√≠mbolo', metadata.symbol],
        ['Decimais', metadata.decimals],
        ['Supply Total', formatTokens(metadata.totalSupply)]
      );
      
      console.log(table.toString());
      
      this.results.metadata = metadata;
      return metadata;
    } catch (error) {
      spinner.fail('Falha ao obter metadados');
      log.error(`Erro: ${error.response?.data?.message || error.message}`);
      throw error;
    }
  }

  // Registrar geradores
  async registerGenerators() {
    log.title('REGISTRANDO GERADORES DE ENERGIA');
    
    const generators = [
      {
        name: 'Painel Solar Residencial',
        account: this.accounts.generator1,
        capacity: 10, // 10 kW
        type: 'Solar'
      },
      {
        name: 'Fazenda E√≥lica',
        account: this.accounts.generator2,
        capacity: 2000, // 2 MW
        type: 'Wind'
      }
    ];

    for (const gen of generators) {
      const spinner = ora(`Registrando ${gen.name}...`).start();
      
      try {
        // Simular registro (sem chave secreta real)
        spinner.text = `Simulando registro de ${gen.name}...`;
        await sleep(2000);
        
        spinner.succeed(`${gen.name} registrado com sucesso!`);
        
        log.info(`Endere√ßo: ${gen.account.publicKey()}`);
        log.info(`Capacidade: ${gen.capacity} kW`);
        log.info(`Tipo: ${gen.type}`);
        
      } catch (error) {
        spinner.fail(`Falha ao registrar ${gen.name}`);
        log.error(`Erro: ${error.response?.data?.message || error.message}`);
      }
    }
    
    this.results.generators = generators;
  }

  // Simular produ√ß√£o de energia e mint de tokens
  async simulateEnergyProduction() {
    log.title('SIMULANDO PRODU√á√ÉO DE ENERGIA E MINT DE TOKENS');
    
    const productions = [
      {
        generator: this.accounts.generator1,
        name: 'Painel Solar',
        production: 50, // 50 kWh
        type: 'Solar',
        recipient: this.accounts.consumer1
      },
      {
        generator: this.accounts.generator2,
        name: 'Fazenda E√≥lica',
        production: 5000, // 5000 kWh
        type: 'Wind',
        recipient: this.accounts.consumer2
      }
    ];

    const table = new Table({
      head: ['Gerador', 'Produ√ß√£o (kWh)', 'Tipo', 'Tokens Gerados', 'Destinat√°rio'],
      colWidths: [20, 15, 10, 20, 25]
    });

    for (const prod of productions) {
      const spinner = ora(`Processando produ√ß√£o de ${prod.name}...`).start();
      
      try {
        // Simular mint de tokens
        spinner.text = `Tokenizando ${prod.production} kWh de energia ${prod.type}...`;
        await sleep(3000);
        
        const tokensGenerated = prod.production * 10000000; // 7 decimais
        
        spinner.succeed(`${prod.production} kWh tokenizados com sucesso!`);
        
        table.push([
          prod.name,
          prod.production,
          prod.type,
          formatTokens(tokensGenerated),
          prod.recipient.publicKey().substring(0, 20) + '...'
        ]);
        
      } catch (error) {
        spinner.fail(`Falha na tokeniza√ß√£o de ${prod.name}`);
        log.error(`Erro: ${error.message}`);
      }
    }
    
    console.log(table.toString());
    this.results.productions = productions;
  }

  // Simular transfer√™ncias P2P
  async simulateP2PTransfers() {
    log.title('SIMULANDO TRANSFER√äNCIAS PEER-TO-PEER');
    
    const transfers = [
      {
        from: this.accounts.consumer1,
        to: this.accounts.consumer2,
        amount: 100000000, // 10 STRGRID
        description: 'Venda de excesso de energia solar'
      },
      {
        from: this.accounts.consumer2,
        to: this.accounts.consumer1,
        amount: 50000000, // 5 STRGRID
        description: 'Compra de energia limpa'
      }
    ];

    const table = new Table({
      head: ['De', 'Para', 'Quantidade', 'Descri√ß√£o'],
      colWidths: [25, 25, 20, 35]
    });

    for (const transfer of transfers) {
      const spinner = ora('Processando transfer√™ncia...').start();
      
      try {
        spinner.text = `Transferindo ${formatTokens(transfer.amount)}...`;
        await sleep(2500);
        
        spinner.succeed('Transfer√™ncia conclu√≠da!');
        
        table.push([
          transfer.from.publicKey().substring(0, 20) + '...',
          transfer.to.publicKey().substring(0, 20) + '...',
          formatTokens(transfer.amount),
          transfer.description
        ]);
        
      } catch (error) {
        spinner.fail('Falha na transfer√™ncia');
        log.error(`Erro: ${error.message}`);
      }
    }
    
    console.log(table.toString());
    this.results.transfers = transfers;
  }

  // Mostrar saldos finais
  async showFinalBalances() {
    log.title('SALDOS FINAIS DAS CONTAS');
    
    const accounts = [
      { name: 'Painel Solar', account: this.accounts.generator1, balance: 0 },
      { name: 'Fazenda E√≥lica', account: this.accounts.generator2, balance: 0 },
      { name: 'Resid√™ncia Urbana', account: this.accounts.consumer1, balance: 400000000 }, // 40 STRGRID
      { name: 'Pequena Empresa', account: this.accounts.consumer2, balance: 4950000000 } // 495 STRGRID
    ];

    const table = new Table({
      head: ['Conta', 'Endere√ßo', 'Saldo (STRGRID)', 'Equivalente (kWh)'],
      colWidths: [20, 45, 20, 20]
    });

    for (const acc of accounts) {
      const spinner = ora(`Consultando saldo de ${acc.name}...`).start();
      
      try {
        // Simular consulta de saldo
        await sleep(1000);
        
        spinner.succeed(`Saldo obtido para ${acc.name}`);
        
        const balanceFormatted = formatTokens(acc.balance);
        const kwhEquivalent = (acc.balance / 10000000).toFixed(0);
        
        table.push([
          acc.name,
          acc.account.publicKey().substring(0, 40) + '...',
          balanceFormatted,
          `${kwhEquivalent} kWh`
        ]);
        
      } catch (error) {
        spinner.fail(`Falha ao obter saldo de ${acc.name}`);
        log.error(`Erro: ${error.message}`);
      }
    }
    
    console.log(table.toString());
  }

  // Mostrar estat√≠sticas finais
  async showFinalStats() {
    log.title('ESTAT√çSTICAS FINAIS DO SISTEMA');
    
    const stats = {
      totalEnergyTokenized: 5050, // kWh
      totalTransactions: 4,
      activeGenerators: 2,
      totalSupply: 505000000000, // 50500 STRGRID
      co2Avoided: 2525 // kg CO2
    };

    const table = new Table();
    table.push(
      ['üîã Energia Total Tokenizada', `${stats.totalEnergyTokenized} kWh`],
      ['üí± Total de Transa√ß√µes', stats.totalTransactions],
      ['üè≠ Geradores Ativos', stats.activeGenerators],
      ['ü™ô Supply Total de Tokens', formatTokens(stats.totalSupply)],
      ['üå± CO‚ÇÇ Evitado', `${stats.co2Avoided} kg`],
      ['üåê Contrato ID', CONTRACT_ID],
      ['üîó Explorer', `https://stellar.expert/explorer/testnet/contract/${CONTRACT_ID}`]
    );
    
    console.log(table.toString());
    
    this.results.finalStats = stats;
  }

  // Executar demonstra√ß√£o completa
  async runFullDemo() {
    console.clear();
    
    // Banner
    console.log(chalk.cyan.bold(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    üåü STELLARGRID TOKEN                     ‚ïë
‚ïë              Demonstra√ß√£o Completa - Hackathon              ‚ïë
‚ïë                                                              ‚ïë
‚ïë        Tokeniza√ß√£o de Energia Renov√°vel na Blockchain       ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`));
    
    try {
      // Executar etapas da demonstra√ß√£o
      await this.initializeAccounts();
      await sleep(2000);
      
      const apiOnline = await this.checkApiStatus();
      if (!apiOnline) {
        log.warning('Continuando com simula√ß√£o offline...');
      }
      await sleep(2000);
      
      await this.getTokenMetadata();
      await sleep(2000);
      
      await this.registerGenerators();
      await sleep(2000);
      
      await this.simulateEnergyProduction();
      await sleep(2000);
      
      await this.simulateP2PTransfers();
      await sleep(2000);
      
      await this.showFinalBalances();
      await sleep(2000);
      
      await this.showFinalStats();
      
      // Conclus√£o
      log.title('DEMONSTRA√á√ÉO CONCLU√çDA COM SUCESSO! üéâ');
      
      console.log(chalk.green.bold(`
‚ú® O StellarGrid Token demonstrou com sucesso:

üîã Tokeniza√ß√£o de energia renov√°vel
üí± Marketplace peer-to-peer descentralizado
üìä Rastreabilidade completa da origem da energia
üå± Incentivos para energia limpa
üöÄ Integra√ß√£o nativa com Stellar blockchain

üèÜ Pronto para revolucionar o mercado de energia!
`));
      
    } catch (error) {
      log.error('Erro durante a demonstra√ß√£o:');
      console.error(error);
    }
  }
}

// Executar demonstra√ß√£o se chamado diretamente
if (require.main === module) {
  const demo = new StellarGridDemo();
  demo.runFullDemo().catch(console.error);
}

module.exports = StellarGridDemo;